/*Description:
斐波数的定义大家都知道： F(0)=F(1)=1 F(n)=F(n-1)+F(n-2) n>1 给出一个斐波数模100余数的序列： 1,1,2,3,5,8,13,21,34,55,89,44,33,77,10,…。 如果已知F(n)的数值，理论上可以倒推n（序号）为何值。例如，给出整数5，因为F(4)=5，即整数5为序号为4的斐波数。给出整数8，得到F(5)=8，即8为n=5的斐波数。 若给出一个二位数，它可能对应斐波数模100余数序列中的不止一个位置，也就是有多个F(n)对应这个二位数。但是总有一个n是最小的。例如，对于整数5，因没有比4更小的n适合F(n)=5，所以4是整数5在追溯斐波数中的最小序号。 所谓斐波追溯数，是指一个斐波数所能追溯的最小序号数。 你的任务是，对于给定的二位数之内的斐波数余数，求斐波追溯数。

Input:
一些0~99的整数。
Output:
对应输入的整数，一行一个地输出其斐波追溯数。
Sample Input:

2 3 8

Sample Output:

2
3
5
*/
#include<iostream>
using namespace std;
int main()
{
	int a[1000]={1,1};
	for (int i=2;i<=999;i++)
		a[i]=(a[i-1]+a[i-2])%100;
	for (int n;cin>>n;)
	{
		for (int num=0;;num++)
			if (a[num]==n) 
			{
				cout<<num<<endl;
				break;
			}
	}
	return 0;
}